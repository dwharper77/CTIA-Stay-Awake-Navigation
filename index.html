<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Stay Awake Navigation</title>

<!-- PWA / standalone hints (only fully apply when installed / Add-to-Home-Screen) -->
<meta name="theme-color" content="#0b1220">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<meta name="format-detection" content="telephone=no">
<link rel="manifest" href="manifest.webmanifest">

<!-- Icons (GitHub Pages-friendly relative paths) -->
<link rel="icon" href="icon.svg" type="image/svg+xml">
<link rel="apple-touch-icon" href="icon.svg">

<style>
  :root {
    --bg: #f6f7fb;
    --card: #ffffff;
    --text: #0f172a;
    --muted: #475569;
    --border: rgba(2, 6, 23, 0.10);
    --shadow: 0 10px 28px rgba(15, 23, 42, 0.08);

    --primary: #2563eb;
    --primary-hover: #1d4ed8;
    --success: #16a34a;
    --success-hover: #15803d;
    --neutral: #64748b;
    --neutral-hover: #475569;
    --danger: #dc2626;
    --danger-hover: #b91c1c;

    --warn-bg: #fff7ed;
    --warn-text: #9a3412;
    --info-bg: #eff6ff;
    --info-text: #1d4ed8;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #0b1220;
      --card: #0f172a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --border: rgba(226, 232, 240, 0.12);
      --shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      --warn-bg: rgba(234, 88, 12, 0.14);
      --warn-text: #fdba74;
      --info-bg: rgba(37, 99, 235, 0.14);
      --info-text: #93c5fd;
    }
  }

  * { box-sizing: border-box; }

  html, body {
    height: 100%;
  }

  body {
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: radial-gradient(1200px 600px at 20% -10%, rgba(37, 99, 235, 0.10), transparent 50%),
                radial-gradient(900px 500px at 100% 0%, rgba(22, 163, 74, 0.08), transparent 55%),
                var(--bg);
    color: var(--text);
    overscroll-behavior: none;
  }

  .app {
    max-width: 620px;
    margin: 0 auto;
    padding: calc(22px + env(safe-area-inset-top)) calc(16px + env(safe-area-inset-right)) calc(32px + env(safe-area-inset-bottom)) calc(16px + env(safe-area-inset-left));
  }

  /* When fullscreen/installed, use the whole screen width */
  :fullscreen .app {
    max-width: 100%;
  }

  @media (display-mode: standalone) {
    .app { max-width: 100%; }
  }

  @media (display-mode: fullscreen) {
    .app { max-width: 100%; }
  }

  .header {
    text-align: left;
    margin-bottom: 14px;
  }

  .headerRow {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
  }

  .header h1 {
    margin: 0;
    font-size: 22px;
    letter-spacing: -0.01em;
  }

  .pill {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(148, 163, 184, 0.12);
    color: var(--text);
    font-size: 12px;
    font-weight: 800;
    letter-spacing: 0.02em;
    user-select: none;
    white-space: nowrap;
  }

  .pillDot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: var(--neutral);
  }

  .pill.is-running { background: rgba(22, 163, 74, 0.12); }
  .pill.is-running .pillDot { background: var(--success); }

  .pill.is-idle { background: rgba(148, 163, 184, 0.12); }
  .pill.is-idle .pillDot { background: var(--neutral); }

  .header p {
    margin: 8px 0 0;
    color: var(--muted);
    line-height: 1.35;
  }

  .actions {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    margin-top: 14px;
  }

  .actions.two {
    grid-template-columns: 1fr 1fr;
  }

  @media (max-width: 420px) {
    .actions.two { grid-template-columns: 1fr; }
  }

  .btn {
    appearance: none;
    border: 1px solid transparent;
    border-radius: 12px;
    padding: 12px 14px;
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 0.01em;
    cursor: pointer;
    width: 100%;
    transition: transform 0.06s ease, background 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
  }

  .btn:active { transform: translateY(1px); }
  .btn:disabled { opacity: 0.55; cursor: not-allowed; }

  .btn-primary { background: var(--primary); color: #fff; }
  .btn-primary:hover { background: var(--primary-hover); }
  .btn-success { background: var(--success); color: #fff; }
  .btn-success:hover { background: var(--success-hover); }
  .btn-neutral { background: var(--neutral); color: #fff; }
  .btn-neutral:hover { background: var(--neutral-hover); }
  .btn-danger { background: var(--danger); color: #fff; }
  .btn-danger:hover { background: var(--danger-hover); }

  .banner {
    display: none;
    margin-top: 14px;
    border-radius: 12px;
    padding: 12px;
    border: 1px solid var(--border);
  }

  .banner-warn { background: var(--warn-bg); color: var(--warn-text); }
  .banner-info { background: var(--info-bg); color: var(--info-text); }

  .card {
    margin-top: 14px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 14px;
    box-shadow: var(--shadow);
    text-align: left;
  }

  .card h2 {
    margin: 0;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--muted);
  }

  .status {
    margin-top: 12px;
    padding: 12px 14px;
    border-radius: 14px;
    border: 1px solid var(--border);
    background: rgba(148, 163, 184, 0.12);
    color: var(--text);
    font-weight: 700;
    text-align: left;
  }

  .kv {
    margin-top: 10px;
    color: var(--muted);
    line-height: 1.3;
  }

  .log {
    margin-top: 8px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    white-space: pre-wrap;
    font-size: 12px;
    color: var(--text);
    background: rgba(148, 163, 184, 0.10);
    border: 1px solid var(--border);
    padding: 10px;
    border-radius: 10px;
    max-height: 220px;
    overflow: auto;
  }

  .subactions {
    display: flex;
    gap: 10px;
    margin-top: 10px;
  }

  .subactions .btn {
    font-size: 14px;
    padding: 10px 12px;
  }

  @media (max-width: 520px) {
    .subactions { flex-direction: column; }
  }
</style>
</head>
<body>

<main class="app">
  <header class="header">
    <div class="headerRow">
      <h1>Stay Awake Navigation</h1>
      <div id="statusPill" class="pill is-idle" aria-live="polite">
        <span class="pillDot" aria-hidden="true"></span>
        <span id="statusPillText">Idle</span>
      </div>
    </div>
    <p>Tap <strong>Start Navigation</strong> to open Google Maps, return here, then tap <strong>Enable Stay Awake</strong> to start the session.</p>
  </header>

  <div class="actions two">
    <button id="navButton" class="btn btn-primary">Start Navigation</button>
    <button id="fullscreenButton" class="btn btn-neutral" type="button">Enter Fullscreen</button>
  </div>

  <div id="warningBanner" class="banner banner-warn"></div>

  <div id="resumeBanner" class="banner banner-info">
    <div style="font-weight:800; margin-bottom:6px;">Previous run detected</div>
    <div id="resumeBannerText" style="font-size:14px; line-height:1.35;"></div>
    <div class="subactions">
      <button id="resumeRunButton" class="btn btn-primary">Resume Run</button>
      <button id="resumeExportButton" class="btn btn-success">Export + Clear</button>
      <button id="resumeClearButton" class="btn btn-neutral">Clear</button>
    </div>
  </div>

  <div class="actions two">
    <button id="wakeButton" class="btn btn-primary">Enable Stay Awake (Start Session)</button>
    <button id="endButton" class="btn btn-neutral" disabled>End Session</button>
  </div>

  <div id="status" class="status">Status: Idle</div>

  <section id="session" class="card">
    <h2>Session</h2>
    <div id="elapsed" class="kv">Elapsed: 00:00:00</div>
    <div id="gpsStatus" class="kv">GPS: Not started</div>
    <div id="focusStatus" class="kv">Focus interruptions: 0</div>
    <div style="margin-top:12px; font-weight:800; color: var(--muted);">Event log</div>
    <div id="eventLog" class="log">(no events yet)</div>
  </section>

  <section id="summary" class="card" style="display:none;">
    <h2>Run Summary</h2>
    <div id="sumElapsed" class="kv"></div>
    <div id="sumFocus" class="kv"></div>
    <div id="sumGpsFailures" class="kv"></div>
    <div id="sumGpsFixes" class="kv"></div>
    <div class="actions" style="margin-top:12px;">
      <button id="exportCsvButton" class="btn btn-primary">Export GPS Log (.csv)</button>
      <button id="exportLogButton" class="btn btn-success">Export Event Log (.txt)</button>
    </div>
  </section>

  <section id="details" class="card">
    <h2>Diagnostics</h2>
    <div id="diagUrl" class="kv"></div>
    <div id="diagDisplayMode" class="kv"></div>
    <div id="diagWakeSupport" class="kv"></div>
    <div id="diagWakeState" class="kv"></div>
    <div id="diagMaps" class="kv"></div>
    <div id="diagStorage" class="kv"></div>
  </section>
</main>

<!-- iOS silent video trick -->
<video id="iosVideo" autoplay muted loop playsinline style="display:none">
  <source src="data:video/mp4;base64,AAAA" type="video/mp4">
</video>

<script>
let wakeLock = null;
const forceIOS = new URLSearchParams(window.location.search).get("forceIOS") === "1";
const isIOS = forceIOS || /iPhone|iPad|iPod/.test(navigator.userAgent);
const isAndroid = /Android/i.test(navigator.userAgent);
let keepAwakeEnabled = false;
let sessionActive = false;
let mapsLaunchState = "Not started";
let mapsLaunchNote = "";
let lastNavTapAt = 0;
let lastHiddenAt = 0;
let lastShownAt = Date.now();
let lastWakeLockError = "";
let lastWakeLockAcquiredAt = 0;
let lastWakeLockReleasedAt = 0;

// Fullscreen (best-effort). Note: browsers only allow this from a user gesture.
function isFullscreenNow() {
  return !!(document.fullscreenElement || document.webkitFullscreenElement);
}

async function requestFullscreenBestEffort() {
  const el = document.documentElement;
  try {
    if (el.requestFullscreen) {
      await el.requestFullscreen({ navigationUI: "hide" });
      return true;
    }
  } catch {
    // ignore
  }

  try {
    // Older Safari/Chrome variants
    if (el.webkitRequestFullscreen) {
      el.webkitRequestFullscreen();
      return true;
    }
  } catch {
    // ignore
  }

  return false;
}

async function exitFullscreenBestEffort() {
  try {
    if (document.exitFullscreen) {
      await document.exitFullscreen();
      return true;
    }
  } catch {
    // ignore
  }

  try {
    if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
      return true;
    }
  } catch {
    // ignore
  }

  return false;
}

function updateFullscreenButton() {
  const btn = document.getElementById("fullscreenButton");
  if (!btn) return;

  const supported = !!(document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen);
  // If not supported (common on iOS Safari unless installed), hide the control.
  btn.style.display = supported ? "" : "none";
  btn.textContent = isFullscreenNow() ? "Exit Fullscreen" : "Enter Fullscreen";
}

// Navigation hardening (best-effort; browsers limit how "sticky" a page can be).
let navGuardArmed = false;
let navGuardAllowExit = false;
let navGuardCounter = 0;
let navGuardBaseUrl = "";

// Simple in-page notification log (helps confirm when things stopped/started).
const EVENT_LOG_MAX = 40;
let eventLog = [];
let eventStore = null;
let suspendEventPersist = false;

function pushNavGuardEntry() {
  if (!navGuardBaseUrl) navGuardBaseUrl = window.location.href.split("#")[0];
  navGuardCounter += 1;
  const url = `${navGuardBaseUrl}#session-${navGuardCounter}`;

  // Using a changing hash makes the history entry distinct and more reliable on mobile.
  try {
    history.pushState({ navGuard: true, id: navGuardCounter }, "", url);
  } catch {
    try {
      window.location.hash = `session-${navGuardCounter}`;
    } catch {
      // ignore
    }
  }
}

function restoreNavGuardUrl() {
  if (!navGuardBaseUrl || !navGuardCounter) return;
  const url = `${navGuardBaseUrl}#session-${navGuardCounter}`;
  try {
    history.replaceState({ navGuard: true, id: navGuardCounter }, "", url);
  } catch {
    try {
      window.location.hash = `session-${navGuardCounter}`;
    } catch {
      // ignore
    }
  }
}

function armNavigationGuard() {
  if (navGuardArmed) return;
  navGuardArmed = true;
  navGuardAllowExit = false;
  navGuardBaseUrl = window.location.href.split("#")[0];
  pushNavGuardEntry();
}

function disarmNavigationGuard() {
  navGuardArmed = false;
  navGuardAllowExit = false;
  try {
    if (navGuardBaseUrl) history.replaceState(history.state, "", navGuardBaseUrl);
  } catch {
    // ignore
  }
}

// Trigger a native "Leave site?" dialog on refresh/close while the session is active.
window.addEventListener("beforeunload", (e) => {
  if (!sessionActive || navGuardAllowExit) return;
  e.preventDefault();
  e.returnValue = "";
});

// Best-effort back-button trap while the session is active.
window.addEventListener("popstate", async () => {
  if (!sessionActive || navGuardAllowExit) return;

  const ok = window.confirm("Session is running. Leave this page?");
  if (!ok) {
    // User chose to stay: restore the guard so Back keeps prompting.
    if (navGuardArmed) pushNavGuardEntry();
    return;
  }

  // User chose to leave: end the session cleanly, then allow navigation.
  try {
    await endSession({ reason: "Left page via Back" });
  } catch {
    // ignore
  }

  navGuardAllowExit = true;
  disarmNavigationGuard();
  try {
    history.back();
  } catch {
    // ignore
  }
});

// Some environments navigate via hash changes instead of popstate.
window.addEventListener("hashchange", () => {
  if (!sessionActive || navGuardAllowExit) return;
  // If something changed the hash away from our guard hash, put it back without adding history.
  if (navGuardArmed && !String(window.location.hash || "").startsWith("#session-")) {
    restoreNavGuardUrl();
  }
});

function logEvent(message) {
  const ts = formatTime(Date.now());
  const entry = `[${ts}] ${message}`;
  eventLog.unshift(entry);
  if (eventLog.length > EVENT_LOG_MAX) eventLog = eventLog.slice(0, EVENT_LOG_MAX);
  const el = document.getElementById("eventLog");
  if (el) el.innerText = eventLog.join("\n");

  // Persist event log (best-effort)
  if (suspendEventPersist) return;
  try {
    const existing = (eventStore && eventStore.loadLog)
      ? eventStore.loadLog()
      : (() => {
          try {
            const raw = window.localStorage.getItem("eventLog");
            const parsed = raw ? JSON.parse(raw) : [];
            return Array.isArray(parsed) ? parsed : [];
          } catch {
            return [];
          }
        })();

    const merged = [entry, ...existing].slice(0, EVENT_LOG_MAX);
    if (eventStore && eventStore.persistLog) eventStore.persistLog(merged);
    else window.localStorage.setItem("eventLog", JSON.stringify(merged));
  } catch {
    // ignore
  }
}

// Session + logging
const GPS_INTERVAL_MS = 10 * 1000;
const GPS_STALE_ALERT_MS = 10 * 60 * 1000;
const GPS_MAX_ACCURACY_METERS = 100; // higher = worse accuracy

let gpsLog = [];
let gpsFailures = 0;
let focusInterruptions = 0;
let lastGpsFixAt = 0;
let gpsFixInFlight = false;
let gpsIntervalId = 0;
let gpsStaleCheckId = 0;
let timerIntervalId = 0;
let sessionStartMs = 0;
let elapsedMs = 0;
let lastTimerTickMs = 0;
let lastStaleAlertAt = 0;

// Persistent GPS storage (survives reloads/crashes/tab kills via localStorage)
let gpsStore = null;
let hasPreviousRun = false;
let storageOk = true;
let storageError = "";

function _loadStoredArray(key) {
  try {
    const raw = window.localStorage.getItem(key);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}

function _appendStoredItem(key, item) {
  const arr = _loadStoredArray(key);
  arr.push(item);
  try {
    window.localStorage.setItem(key, JSON.stringify(arr));
  } catch {
    // ignore
  }
  return arr.length;
}

function storageSelfTest() {
  const key = "__pwa_storage_test__";
  const value = `ok-${Date.now()}`;
  try {
    window.localStorage.setItem(key, value);
    const roundTrip = window.localStorage.getItem(key);
    window.localStorage.removeItem(key);

    if (roundTrip !== value) {
      storageOk = false;
      storageError = "localStorage read-back mismatch";
      return false;
    }

    storageOk = true;
    storageError = "";
    return true;
  } catch (e) {
    storageOk = false;
    storageError = (e && e.message) ? e.message : "localStorage blocked";
    return false;
  }
}

function _hideResumeBanner() {
  const banner = document.getElementById("resumeBanner");
  if (banner) banner.style.display = "none";
}

function _showResumeBanner({ gpsCount, eventCount }) {
  const banner = document.getElementById("resumeBanner");
  const text = document.getElementById("resumeBannerText");
  if (text) text.innerText = `Found ${gpsCount} GPS fixes and ${eventCount} log events saved on this device.`;
  if (banner) banner.style.display = "block";

  const resumeBtn = document.getElementById("resumeRunButton");
  const exportBtn = document.getElementById("resumeExportButton");
  const clearBtn = document.getElementById("resumeClearButton");

  if (resumeBtn) {
    resumeBtn.onclick = () => {
      // Nothing special is required to keep storing. This is just an explicit acknowledgement.
      _hideResumeBanner();
      clearWarning();
      setStatus("Resumed previous run (continuing)");
      updateDiagnostics();
      logEvent("Resumed previous run");
    };
  }

  if (exportBtn) {
    exportBtn.onclick = async () => {
      // Export GPS from storage if available
      if (window.exportRun) {
        await window.exportRun();
      } else {
        // Fallback: load stored GPS into memory for exportGpsCsv()
        gpsLog = _loadStoredArray("gpsLog");
        exportGpsCsv();
        try {
          window.localStorage.removeItem("gpsLog");
        } catch {
          // ignore
        }
        gpsLog = [];
      }

      // Export Event Log from storage if available
      const storedEvents = (eventStore && eventStore.loadLog) ? eventStore.loadLog() : _loadStoredArray("eventLog");
      eventLog = Array.isArray(storedEvents) ? storedEvents.slice(0, EVENT_LOG_MAX) : [];
      exportEventLogTxt();
      try {
        if (eventStore && eventStore.clearLog) eventStore.clearLog();
        else window.localStorage.removeItem("eventLog");
      } catch {
        // ignore
      }
      eventLog = [];
      const el = document.getElementById("eventLog");
      if (el) el.innerText = "(no events yet)";

      hasPreviousRun = false;
      window.hasPreviousRun = false;
      _hideResumeBanner();
      updateDiagnostics();
    };
  }

  if (clearBtn) {
    clearBtn.onclick = () => {
      if (window.clearRun) {
        window.clearRun();
      } else {
        try {
          window.localStorage.removeItem("gpsLog");
          window.localStorage.removeItem("eventLog");
        } catch {
          // ignore
        }
        gpsLog = [];
        eventLog = [];
        const el = document.getElementById("eventLog");
        if (el) el.innerText = "(no events yet)";
      }

      hasPreviousRun = false;
      window.hasPreviousRun = false;
      _hideResumeBanner();
      updateDiagnostics();
    };
  }
}

async function initGpsStore() {
  try {
    gpsStore = await import("./gpsLogger.js");
    eventStore = await import("./eventLogger.js");

    const storedGpsCount = gpsStore.loadRun().length;
    const storedEventCount = eventStore.loadLog().length;
    const hasGps = storedGpsCount > 0;
    const hasEvents = storedEventCount > 0;

    hasPreviousRun = hasGps || hasEvents;
    window.hasPreviousRun = hasPreviousRun;

    if (hasPreviousRun) {
      _showResumeBanner({ gpsCount: storedGpsCount, eventCount: storedEventCount });
    }

    // Expose helpers for UI/buttons/console.
    window.exportRun = async () => {
      const ok = gpsStore.exportRun();
      if (ok) {
        gpsLog = [];
        hasPreviousRun = false;
        window.hasPreviousRun = false;
        logEvent("Exported stored GPS log and cleared localStorage");
        clearWarning();
        updateDiagnostics();
      }
      return ok;
    };

    window.clearRun = () => {
      gpsStore.clearRun();
      gpsLog = [];
      // Clear the saved event log too (treat as one "run")
      try {
        if (eventStore && eventStore.clearLog) eventStore.clearLog();
      } catch {
        // ignore
      }
      eventLog = [];
      const el = document.getElementById("eventLog");
      if (el) el.innerText = "(no events yet)";

      hasPreviousRun = false;
      window.hasPreviousRun = false;
      // Avoid writing a new persisted log entry after clearing.
      suspendEventPersist = true;
      try {
        logEvent("Cleared stored run data (debug)");
      } finally {
        suspendEventPersist = false;
      }
      clearWarning();
      updateDiagnostics();
    };
  } catch (e) {
    gpsStore = null;
    eventStore = null;
    // Fallback: still detect stored data and show resume controls.
    const storedGpsCount = _loadStoredArray("gpsLog").length;
    const storedEventCount = _loadStoredArray("eventLog").length;
    hasPreviousRun = storedGpsCount > 0 || storedEventCount > 0;
    window.hasPreviousRun = hasPreviousRun;
    if (hasPreviousRun) {
      _showResumeBanner({ gpsCount: storedGpsCount, eventCount: storedEventCount });
    }
    logEvent("Run persistence modules failed to load; using localStorage fallback");
  }
}

// Audio
let audioCtx = null;
let audioEnabled = false;

function formatTime(ms) {
  try {
    return new Date(ms).toLocaleTimeString();
  } catch {
    return "";
  }
}

function formatElapsed(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, "0");
  const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, "0");
  const seconds = String(totalSeconds % 60).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}

function setStatus(text) {
  document.getElementById("status").innerText = `Status: ${text}`;
  updateStatusPill();
  updateDiagnostics();
}

function updateStatusPill() {
  const pill = document.getElementById("statusPill");
  const label = document.getElementById("statusPillText");
  if (!pill || !label) return;

  const isRunning = !!sessionActive;
  pill.classList.toggle("is-running", isRunning);
  pill.classList.toggle("is-idle", !isRunning);
  label.innerText = isRunning ? "Running" : "Idle";
}

function showWarning(message) {
  const el = document.getElementById("warningBanner");
  el.style.display = message ? "block" : "none";
  el.innerText = message || "";
}

function clearWarning() {
  showWarning("");
}

function setText(id, text) {
  const el = document.getElementById(id);
  if (!el) return;
  el.innerText = text;
}

function getWakeLockStateText() {
  if (!keepAwakeEnabled) return "Off";
  if (wakeLock) return "On";
  if (lastWakeLockError) return `Off (error: ${lastWakeLockError})`;
  return "On (requested)";
}

function updateDiagnostics() {
  setText("diagUrl", `URL: ${window.location.href}`);

  // Display mode (helps confirm when installed as an app)
  let displayMode = "browser";
  try {
    if (window.matchMedia && window.matchMedia("(display-mode: fullscreen)").matches) {
      displayMode = "fullscreen";
    } else if (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) {
      displayMode = "standalone";
    }
  } catch {
    // ignore
  }
  if (isFullscreenNow()) {
    // If the Fullscreen API is active, that's the best immediate signal.
    displayMode = "fullscreen";
  }
  setText("diagDisplayMode", `Display mode: ${displayMode}`);

  setText(
    "diagWakeSupport",
    `Wake Lock: ${isIOS ? "iOS fallback (silent video)" : (("wakeLock" in navigator) ? "Supported" : "Not supported")}`
  );
  setText("diagWakeState", `Wake lock: ${getWakeLockStateText()}`);

  // Simple signal only: when the user pressed Start Navigation.
  setText(
    "diagMaps",
    lastNavTapAt ? `Google Maps: Start Navigation started at ${formatTime(lastNavTapAt)}` : "Google Maps: Not started"
  );

  // Persistent storage visibility
  let storedGpsCount = 0;
  let storedEventCount = 0;
  try {
    storedGpsCount = _loadStoredArray("gpsLog").length;
    storedEventCount = _loadStoredArray("eventLog").length;
  } catch {
    // ignore
  }
  const gpsMode = (gpsStore && gpsStore.saveFix) ? "module" : "fallback";
  const eventMode = (eventStore && eventStore.persistLog) ? "module" : "fallback";
  setText(
    "diagStorage",
    `Stored run data (localStorage): gpsLog=${storedGpsCount} fixes (${gpsMode}), eventLog=${storedEventCount} events (${eventMode}) | storage=${storageOk ? "OK" : "BLOCKED"}`
  );

  // Session info
  const elapsedEl = document.getElementById("elapsed");
  if (elapsedEl) elapsedEl.innerText = `Elapsed: ${formatElapsed(elapsedMs)}`;

  const gpsEl = document.getElementById("gpsStatus");
  if (gpsEl) {
    if (!sessionActive) {
      gpsEl.innerText = "GPS: Not started";
    } else if (lastGpsFixAt) {
      const ageSec = Math.floor((Date.now() - lastGpsFixAt) / 1000);
      gpsEl.innerText = `GPS: ${gpsLog.length} fixes, last ${ageSec}s ago (failures: ${gpsFailures})`;
    } else {
      gpsEl.innerText = `GPS: No fixes yet (failures: ${gpsFailures})`;
    }
  }

  const focusEl = document.getElementById("focusStatus");
  if (focusEl) focusEl.innerText = `Focus interruptions: ${focusInterruptions}`;
}

function getSecureContextHint() {
  // Wake Lock requires a secure context. On Android, opening local files often uses content://
  // which is not considered secure, so the API will be unavailable or will throw.
  const protocol = window.location.protocol;
  const href = window.location.href;

  if (window.isSecureContext) return null;

  if (protocol === "content:") {
    return "Opened as content:// (not secure). Serve this page over https:// or http://localhost.";
  }
  if (protocol === "file:") {
    return "Opened as file:// (not secure). Serve this page over https:// or http://localhost.";
  }
  if (protocol === "http:" && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1")) {
    return null;
  }
  return `Not a secure context (${protocol}). Use https:// (or http://localhost). Current URL: ${href}`;
}

function updateWakeButtonState() {
  const wakeBtn = document.getElementById("wakeButton");
  if (wakeBtn) wakeBtn.disabled = !!sessionActive;
}

async function enableWakeLock() {
  keepAwakeEnabled = true;
  setStatus("Activating…");

  if (isIOS) {
    // iOS fallback: silent looping video
    const vid = document.getElementById("iosVideo");
    try {
      await vid.play();
      lastWakeLockAcquiredAt = Date.now();
      logEvent("Wake mode started (iOS video fallback)");
      setStatus("iOS wake mode active");
    } catch (e) {
      setStatus("Tap the screen to activate iOS wake mode");
    }
    return;
  }

  const secureHint = getSecureContextHint();
  if (secureHint) {
    setStatus(`Wake lock blocked. ${secureHint}`);
    return;
  }

  if (!("wakeLock" in navigator)) {
    setStatus("Wake Lock API not available in this browser/context");
    return;
  }

  // Android Wake Lock API
  try {
    lastWakeLockError = "";
    wakeLock = await navigator.wakeLock.request("screen");
    lastWakeLockAcquiredAt = Date.now();
    logEvent("Wake lock acquired");
    setStatus("Android wake lock active");

    wakeLock.addEventListener("release", () => {
      wakeLock = null;
      lastWakeLockReleasedAt = Date.now();

      // If we didn't intentionally end the session and we're still visible, treat as unexpected.
      if (sessionActive && document.visibilityState === "visible") {
        playAlert();
        showWarning("Wake lock released unexpectedly. Tap 'Enable Stay Awake' again.");
        logEvent("Wake lock released unexpectedly (while visible)");
      } else {
        logEvent("Wake lock released");
      }
      setStatus("Wake lock released");
    });
  } catch (err) {
    const name = err && err.name ? err.name : "Error";
    const message = err && err.message ? err.message : "Wake lock request failed";
    lastWakeLockError = `${name}: ${message}`;
    logEvent(`Wake lock request failed: ${lastWakeLockError}`);
    setStatus(`${name}: ${message}`);
  }
}

function ensureAudio() {
  // Must be called from a user gesture.
  try {
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      audioCtx = new Ctx();
    }
    if (audioCtx.state === "suspended") {
      audioCtx.resume();
    }
    audioEnabled = true;
  } catch {
    audioEnabled = false;
  }
}

function playAlert() {
  // Short beep. If audio is blocked, we still show warnings.
  if (!audioEnabled || !audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.value = 880;
    gain.gain.value = 0.0001;
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(0.15, now + 0.02);
    gain.gain.linearRampToValueAtTime(0.0001, now + 0.20);
    osc.start(now);
    osc.stop(now + 0.22);
  } catch {
    // ignore
  }
}

function startTimer() {
  sessionStartMs = Date.now();
  lastTimerTickMs = Date.now();
  if (timerIntervalId) window.clearInterval(timerIntervalId);
  timerIntervalId = window.setInterval(() => {
    if (!sessionActive) return;
    if (document.visibilityState !== "visible") return;
    const now = Date.now();
    elapsedMs += Math.max(0, now - lastTimerTickMs);
    lastTimerTickMs = now;
    updateDiagnostics();
  }, 1000);
}

function pauseTimer() {
  if (!sessionActive) return;
  const now = Date.now();
  elapsedMs += Math.max(0, now - lastTimerTickMs);
  lastTimerTickMs = now;
  updateDiagnostics();
}

function resumeTimer() {
  if (!sessionActive) return;
  lastTimerTickMs = Date.now();
  updateDiagnostics();
}

function requestGpsFix({ purpose }) {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation || !navigator.geolocation.getCurrentPosition) {
      reject(new Error("Geolocation not supported"));
      return;
    }
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const fix = {
          timestamp: new Date().toISOString(),
          deviceTimestampMs: typeof pos.timestamp === "number" ? pos.timestamp : null,
          lat: pos.coords.latitude,
          lon: pos.coords.longitude,
          accuracy: pos.coords.accuracy,
          altitude: pos.coords.altitude,
          altitudeAccuracy: pos.coords.altitudeAccuracy,
          speed: pos.coords.speed,
          heading: pos.coords.heading,
        };
        resolve({ fix, purpose });
      },
      (err) => reject(err),
      {
        enableHighAccuracy: true,
        timeout: 20000,
        maximumAge: 0,
      }
    );
  });
}

async function gpsHealthCheck() {
  try {
    setStatus("Checking GPS…");
    const { fix } = await requestGpsFix({ purpose: "health" });

    if (typeof fix.accuracy === "number" && fix.accuracy > GPS_MAX_ACCURACY_METERS) {
      playAlert();
      showWarning(`GPS accuracy is greater than 100m (${Math.round(fix.accuracy)}m).`);
      throw new Error("GPS accuracy low");
    }

    clearWarning();
    setStatus("GPS OK");
    updateWakeButtonState();
    return true;
  } catch (e) {
    playAlert();
    showWarning("GPS health check failed. Fix GPS/permissions, then try again.");
    setStatus("GPS check failed");
    return false;
  }
}

async function collectGpsFix() {
  if (!sessionActive) return;
  if (gpsFixInFlight) return;
  gpsFixInFlight = true;
  try {
    const { fix } = await requestGpsFix({ purpose: "interval" });

    if (typeof fix.accuracy === "number" && fix.accuracy > GPS_MAX_ACCURACY_METERS) {
      gpsFailures += 1;
      playAlert();
      showWarning(`GPS accuracy is greater than 100m (${Math.round(fix.accuracy)}m).`);
      updateDiagnostics();
      return;
    }

    // Persist each fix immediately (survives reload/crash/tab kill).
    // Prefer gpsLogger.js, but fall back to raw localStorage so persistence still works even if module import fails.
    try {
      if (gpsStore && gpsStore.saveFix) {
        gpsStore.saveFix(fix);
      } else {
        _appendStoredItem("gpsLog", fix);
      }
    } catch {
      // ignore storage errors; keep in-memory logging running
    }

    gpsLog.push(fix);
    lastGpsFixAt = Date.now();
    clearWarning();
    updateDiagnostics();
  } catch {
    gpsFailures += 1;
    playAlert();
    showWarning("GPS fix failed. Ensure Location is ON and permission is granted.");
    updateDiagnostics();
  } finally {
    gpsFixInFlight = false;
  }
}

function startGpsLogging() {
  if (gpsIntervalId) window.clearInterval(gpsIntervalId);
  if (gpsStaleCheckId) window.clearInterval(gpsStaleCheckId);

  // Collect one immediately, then every 10 seconds.
  collectGpsFix();
  gpsIntervalId = window.setInterval(collectGpsFix, GPS_INTERVAL_MS);

  // Stale check every minute.
  gpsStaleCheckId = window.setInterval(() => {
    if (!sessionActive) return;
    if (!lastGpsFixAt) return;
    const age = Date.now() - lastGpsFixAt;
    if (age > GPS_STALE_ALERT_MS) {
      const now = Date.now();
      if (!lastStaleAlertAt || now - lastStaleAlertAt > 2 * 60 * 1000) {
        lastStaleAlertAt = now;
        playAlert();
        showWarning("No GPS fix for over 10 minutes.");
      }
    }
  }, 60 * 1000);
}

function downloadTextFile({ filename, content, mimeType }) {
  const blob = new Blob([content], { type: mimeType || "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function safeFileTimestamp() {
  return new Date().toISOString().replace(/[:.]/g, "-");
}

function exportGpsCsv() {
  const header = "timestamp,deviceTimestampMs,lat,lon,accuracy,altitude,altitudeAccuracy,speed,heading";
  const rows = gpsLog.map((fix) => {
    const ts = fix.timestamp ?? "";
    const deviceTs = (fix.deviceTimestampMs ?? "").toString();
    const lat = (fix.lat ?? "").toString();
    const lon = (fix.lon ?? "").toString();
    const acc = (fix.accuracy ?? "").toString();
    const alt = (fix.altitude ?? "").toString();
    const altAcc = (fix.altitudeAccuracy ?? "").toString();
    const speed = (fix.speed ?? "").toString();
    const heading = (fix.heading ?? "").toString();
    // Values are numeric/ISO; keep simple CSV with commas.
    return `${ts},${deviceTs},${lat},${lon},${acc},${alt},${altAcc},${speed},${heading}`;
  });
  const csv = [header, ...rows].join("\r\n") + "\r\n";
  downloadTextFile({
    filename: `gps-log-${safeFileTimestamp()}.csv`,
    content: csv,
    mimeType: "text/csv",
  });
}

function exportEventLogTxt() {
  const headerLines = [
    `Activity Log`,
    `Generated: ${new Date().toISOString()}`,
    `URL: ${window.location.href}`,
    `User agent: ${navigator.userAgent}`,
    "",
  ];

  // Prefer persisted log (if available) so exports survive reloads/crashes.
  let source = eventLog;
  try {
    if (eventStore && eventStore.loadLog) {
      const stored = eventStore.loadLog();
      if (Array.isArray(stored) && stored.length) source = stored;
    }
  } catch {
    // ignore
  }

  // Log is newest-first; export oldest-first for readability.
  const lines = source.length ? source.slice().reverse() : ["(no events)"];
  const content = headerLines.concat(lines).join("\r\n") + "\r\n";

  downloadTextFile({
    filename: `activity-log-${safeFileTimestamp()}.txt`,
    content,
    mimeType: "text/plain",
  });
}

function exportEventLogAndClear() {
  // Export from storage (preferred) and only then clear the stored log.
  exportEventLogTxt();
  try {
    if (eventStore && eventStore.clearLog) eventStore.clearLog();
    else window.localStorage.removeItem("eventLog");
  } catch {
    // ignore
  }
}

function showRunSummary() {
  const sum = document.getElementById("summary");
  if (!sum) return;
  sum.style.display = "block";
  document.getElementById("sumElapsed").innerText = `Total elapsed time: ${formatElapsed(elapsedMs)}`;
  document.getElementById("sumFocus").innerText = `Focus interruptions: ${focusInterruptions}`;
  document.getElementById("sumGpsFailures").innerText = `GPS failures: ${gpsFailures}`;
  document.getElementById("sumGpsFixes").innerText = `GPS fixes collected: ${gpsLog.length}`;
}

let endingSession = false;
async function endSession({ reason = "Session ended" } = {}) {
  if (!sessionActive || endingSession) return;
  endingSession = true;

  setStatus("Ending session…");
  sessionActive = false;
  keepAwakeEnabled = false;
  logEvent(reason);

  // Stop timers
  if (gpsIntervalId) window.clearInterval(gpsIntervalId);
  if (gpsStaleCheckId) window.clearInterval(gpsStaleCheckId);
  if (timerIntervalId) window.clearInterval(timerIntervalId);
  gpsIntervalId = 0;
  gpsStaleCheckId = 0;
  timerIntervalId = 0;

  // Release wake lock if held
  try {
    if (wakeLock) {
      await wakeLock.release();
      wakeLock = null;
    }
  } catch {
    // ignore
  }

  // iOS video can just stop playing when page is done; don't hard-fail.
  try {
    const vid = document.getElementById("iosVideo");
    if (vid) {
      vid.pause();
      vid.currentTime = 0;
    }
  } catch {
    // ignore
  }

  pauseTimer();
  showRunSummary();
  setStatus("Session ended");
  updateWakeButtonState();
  updateDiagnostics();
  endingSession = false;
}

document.getElementById("wakeButton").onclick = async () => {
  // Must be user gesture for audio + permissions.
  ensureAudio();

  // Best-effort fullscreen (works in many Android browsers; iOS usually requires Add-to-Home-Screen).
  await requestFullscreenBestEffort();

  // Pre-run GPS health check
  const gpsOk = await gpsHealthCheck();
  if (!gpsOk) return;

  // Start session
  clearWarning();
  sessionActive = true;
  armNavigationGuard();
  keepAwakeEnabled = true;
  lastTimerTickMs = Date.now();
  logEvent("Session started");
  const endBtn = document.getElementById("endButton");
  if (endBtn) endBtn.disabled = false;

  // Acquire wake lock (or iOS video fallback)
  await enableWakeLock();
  startTimer();
  startGpsLogging();
  setStatus("Session running");
  updateWakeButtonState();
};

document.getElementById("endButton").onclick = async () => {
  if (!sessionActive) return;
  disarmNavigationGuard();
  await endSession({ reason: "Session ended" });
};

document.getElementById("fullscreenButton").onclick = async () => {
  if (isFullscreenNow()) {
    await exitFullscreenBestEffort();
  } else {
    await requestFullscreenBestEffort();
  }
  updateFullscreenButton();
};

document.addEventListener("fullscreenchange", updateFullscreenButton);
document.addEventListener("webkitfullscreenchange", updateFullscreenButton);
updateFullscreenButton();

document.getElementById("exportCsvButton").onclick = async () => {
  if (window.exportRun) {
    await window.exportRun();
    return;
  }
  // Fallback: export in-memory log if persistence isn't available.
  exportGpsCsv();
};
document.getElementById("exportLogButton").onclick = exportEventLogAndClear;

// If the tab becomes hidden, Chromium will usually release the lock.
// Re-acquire it when returning to the tab (only if the user enabled it).
document.addEventListener("visibilitychange", async () => {
  // Focus monitor + audible alarms
  if (document.visibilityState === "hidden") {
    lastHiddenAt = Date.now();
    if (sessionActive) {
      focusInterruptions += 1;
      playAlert();
      showWarning("Page lost focus/visibility. Return to the page to continue the test.");
      logEvent("Switched away (page hidden) — wake lock may stop until you return");
      pauseTimer();
    }
    updateDiagnostics();
    return;
  }

  // visible
  lastShownAt = Date.now();
  if (sessionActive) {
    clearWarning();
    resumeTimer();
    logEvent("Returned (page visible)");
  }

  // If it was released while hidden, try to re-acquire.
  if (keepAwakeEnabled && !isIOS && document.visibilityState === "visible") {
    if (!wakeLock) {
      logEvent("Attempting to re-acquire wake lock…");
      await enableWakeLock();
    }
  }

  updateDiagnostics();
});

// Initialize diagnostics ASAP
storageSelfTest();
if (!storageOk) {
  showWarning(
    "Persistent storage appears to be blocked in this browser mode. GPS fixes and the event log may NOT survive reloads/crashes. " +
      "Try non-private mode or allow site data. Details: " +
      storageError
  );
}
updateDiagnostics();
updateStatusPill();
logEvent("Page loaded");
initGpsStore();

// Best-effort Maps/app-switch detection.
// Web pages cannot truly verify if another app (Google Maps) is currently running.
// We can only infer that an app switch likely happened if the page is backgrounded
// immediately after the user tapped "Start Navigation".
window.addEventListener("blur", () => {
  if (!lastNavTapAt) return;
  const delta = Date.now() - lastNavTapAt;
  if (delta >= 0 && delta <= 5000) {
    mapsLaunchState = "Likely opened (page lost focus)";
    mapsLaunchNote = "Cannot verify Maps is running; this only indicates an app/tab switch.";
    updateDiagnostics();
  }
});

window.addEventListener("pageshow", () => {
  lastShownAt = Date.now();
  updateDiagnostics();
});

// Initialize button state
updateWakeButtonState();

// PWA: service worker registration (GitHub Pages is HTTPS, so this should work)
if ("serviceWorker" in navigator) {
  window.addEventListener("load", async () => {
    try {
      await navigator.serviceWorker.register("./sw.js", { scope: "./" });
      logEvent("Service worker registered");
    } catch (e) {
      // Not fatal (e.g., file://, unsupported browser, or SW blocked)
      try {
        logEvent(`Service worker registration failed: ${e?.message || e}`);
      } catch {
        // ignore
      }
    }
  });
}

document.getElementById("navButton").onclick = () => {
  // Important: Wake Lock is tied to THIS page/tab. If we navigate away in the same tab,
  // the browser must release the wake lock.
  setStatus("Opening navigation… (wake lock will release when leaving this page)");

  lastNavTapAt = Date.now();
  logEvent("Start Navigation tapped");
  mapsLaunchState = "Launch requested";
  mapsLaunchNote = "Waiting to see if the page backgrounds (best-effort signal).";
  updateDiagnostics();

  const destination = encodeURIComponent("Starbucks");
  const webUrl = `https://www.google.com/maps/dir/?api=1&destination=${destination}&travelmode=driving&dir_action=navigate`;

  // iOS: attempt to deep-link into the Google Maps app if installed.
  // If it fails (not installed / blocked), fall back to the web URL.
  if (isIOS) {
    mapsLaunchState = "Launching (attempting Google Maps app)…";
    mapsLaunchNote = "iOS will prompt if allowed; otherwise falls back to web.";
    updateDiagnostics();

    // Google Maps URL scheme docs: comgooglemaps://
    // Use daddr for destination, directionsmode for driving.
    const appUrl = `comgooglemaps://?daddr=${destination}&directionsmode=driving`;
    const startVisibility = document.visibilityState;
    const startTime = Date.now();
    window.location.href = appUrl;

    window.setTimeout(() => {
      const stillVisible = document.visibilityState === startVisibility && document.visibilityState === "visible";
      const elapsed = Date.now() - startTime;
      if (stillVisible && elapsed >= 1200) {
        mapsLaunchState = "Google Maps app not detected";
        mapsLaunchNote = "Install Google Maps (or allow opening app links) to use Start Navigation.";
        updateDiagnostics();
        showWarning("Google Maps app was not opened. Install Google Maps (or allow opening app links), then try again.");
        logEvent("Google Maps app not detected (no fallback to web)");
        setStatus("Google Maps app not detected");
      } else {
        mapsLaunchState = "Likely opened";
        mapsLaunchNote = "Cannot verify running state; only inferred from app/tab switch.";
        updateDiagnostics();
      }
    }, 1500);
    return;
  }

  // On Android this typically deep-links into the Google Maps app (recommended).
  // If it doesn't, it will still open the Maps website.
  if (isAndroid) {
    mapsLaunchState = "Launching (attempting Maps app)…";
    mapsLaunchNote = "If the page backgrounds, Maps likely opened.";
    updateDiagnostics();

    // Prefer a direct navigation intent first.
    // If this fails (e.g., Maps not installed), we fall back to the web URL.
    const intentUrl = `intent://maps.google.com/maps?daddr=${destination}&directionsmode=driving#Intent;scheme=https;package=com.google.android.apps.maps;end`;

    const startVisibility = document.visibilityState;
    const startTime = Date.now();
    window.location.href = intentUrl;

    // If we stay visible, assume the intent didn’t switch apps and fall back to web.
    window.setTimeout(() => {
      const stillVisible = document.visibilityState === startVisibility && document.visibilityState === "visible";
      const elapsed = Date.now() - startTime;
      if (stillVisible && elapsed >= 1200) {
        mapsLaunchState = "Google Maps app not detected";
        mapsLaunchNote = "Install Google Maps (or allow opening app links) to use Start Navigation.";
        updateDiagnostics();
        showWarning("Google Maps app was not opened. Install Google Maps (or allow opening app links), then try again.");
        logEvent("Google Maps app not detected (no fallback to web)");
        setStatus("Google Maps app not detected");
      } else {
        mapsLaunchState = "Likely opened";
        mapsLaunchNote = "Cannot verify running state; only inferred from app/tab switch.";
        updateDiagnostics();
      }
    }, 1500);
    return;
  }

  // Non-Android fallback
  mapsLaunchState = "Opening Maps web";
  mapsLaunchNote = "Wake lock will only apply while this page is foreground.";
  updateDiagnostics();
  window.location.href = webUrl;
};
</script>

</body>
</html>